from SCons.Subst import quote_spaces
from SCons.Platform import TempFileMunge

import SCons
import os
import sys
import re
import multiprocessing


vars = Variables(None, ARGUMENTS)
vars.Add(BoolVariable("VERBOSE", help="Print full commands", default=0))
vars.Add(BoolVariable("FORCE", help="Force target action", default=0))
vars.Add(BoolVariable("DEBUG", help="Enable debug build", default=1))
vars.Add(BoolVariable("COMPACT", help="Optimize for size", default=0))
vars.Add(
    EnumVariable(
        "TARGET_HW",
        help="Hardware target",
        default="7",
        allowed_values=[
            "7",
        ],
    )
)
vars.Add(
    BoolVariable("RAM_EXEC", help="Build updater image for RAM exection", default=0)
)


env = Environment(
    variables=vars,
    tools=["as", "gcc", "g++", "ar", "gnulink", "python", "compilation_db"],
    OBJCOPY="objcopy",
    PYTHON3="python3",
    STRIP="strip",
    STRIPFLAGS=[],
    STRIPCOM="$STRIP $STRIPFLAGS $SOURCES -o $TARGET",
    TEMPFILE=TempFileMunge,
    MAXLINELENGTH=2048,
    PROGSUFFIX=".elf",
    COMPILATIONDB_USE_ABSPATH=True,
    ENV={
        "PATH": os.environ["PATH"],
    },
)

if not env["VERBOSE"]:
    env.Replace(
        CCCOMSTR="\tCC\t${SOURCE}",
        CXXCOMSTR="\tCPP\t${SOURCE}",
        ASCOMSTR="\tASM\t${SOURCE}",
        ARCOMSTR="\tAR\t${TARGET}",
        RANLIBCOMSTR="\tRANLIB\t${TARGET}",
        LINKCOMSTR="\tLINK\t${TARGET}",
        INSTALLSTR="\tINSTALL\t${SOURCE}",
        APPSCOMSTR="\tAPPS\t${TARGET}",
        VERSIONCOMSTR="\tVERSION\t${TARGET}",
        # STRIPCOMSTR="\tSTRIP\t${TARGET}",
    )

if env["PLATFORM"] == "win32":
    # On Windows, Python 3 executable is usually just "python"
    env["PYTHON3"] = env["PYTHON3"][:-1]

Help(vars.GenerateHelpText(env))


# Default value for -j

SetOption("num_jobs", multiprocessing.cpu_count())
SetOption("implicit_cache", True)
# SetOption("implicit_deps_unchanged", True)
SetOption("max_drift", 1)
# env.Decider("content-timestamp")


# Setting up temp file parameters

WINPATHSEP_RE = re.compile(r"\\([^\"'\\]|$)")


def tempfile_arg_esc_func(arg):
    arg = quote_spaces(arg)
    if env["PLATFORM"] != "win32":
        return arg
    # GCC requires double Windows slashes, let's use UNIX separator
    return WINPATHSEP_RE.sub(r"/\1", arg)


env["TEMPFILEARGESCFUNC"] = tempfile_arg_esc_func


# Set up cross-compile tools

TOOLCHAIN_PREFIX = "arm-none-eabi-"

for binary in [
    "AR",
    "AS",
    "CC",
    "CXX",
    "OBJCOPY",
    "RANLIB",
    "STRIP",
]:
    if binary in env:
        env[binary] = TOOLCHAIN_PREFIX + env[binary]


# Commandline length limit hack

env["LINKCOM"] = '${TEMPFILE("' + env["LINKCOM"] + '","$LINKCOMSTR")}'
env["ARCOM"] = '${TEMPFILE("' + env["ARCOM"] + '","$ARCOMSTR")}'


# Build env extensions


def GlobRecursive(env, pattern, node=".", exclude=None):
    results = []
    if isinstance(node, str):
        node = Dir(node)
    for f in node.glob("*", source=True, exclude=exclude):
        if isinstance(f, SCons.Node.FS.Dir):
            results += env.GlobRecursive(pattern, f, exclude)
    results += node.glob(
        pattern,
        source=True,
        exclude=exclude,
    )
    # print(f"Glob for {pattern} from {node}: {results}")
    return results


def BuildModule(env, module):
    # print("cwd", os.getcwd())
    # print(type(Dir(".").srcdir), dir(Dir(".").srcdir))
    src_dir = str(Dir(".").srcdir or os.getcwd())
    module_sconscript = os.path.join(src_dir, module, "SConscript")
    if not os.path.exists(module_sconscript):
        module_sconscript = os.path.join(src_dir, f"{module}.scons")
        if not os.path.exists(module_sconscript):
            print(f"Cannot build module {module}: scons file not found")
            Exit(2)

    return env.SConscript(
        module_sconscript,
        variant_dir=env["BUILD_DIR"] + "/" + module,
        duplicate=0,
    )


def BuildModules(env, modules):
    result = []
    for module in modules:
        build_res = env.BuildModule(module)
        # print("module ", module, build_res)
        if build_res is None:
            continue
        elif isinstance(build_res, list):
            result.extend(build_res)
        else:
            result.append(build_res[0])  # ???
    return result


env.AddMethod(GlobRecursive)
env.AddMethod(BuildModule)
env.AddMethod(BuildModules)

Export("env")
